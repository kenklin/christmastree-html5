<!DOCTYPE html>
<html>
<body>

<canvas id="myCanvas" width="200" height="250" style="border:1px solid #c3c3c3;">
Your browser does not support the HTML5 canvas tag.
</canvas>
<div id="msg" style="width:200px;text-align:center">Season's Greetings,<br>
<a href="https://github.com/kenklin/christmastree-html5">Ken Lin</a></div>

<script>
var msg=document.getElementById('msg').textContent;
var args={
  msg:"",
  bgColor:'white',
  tree: {
    w:200,
    h:250,
    hCenter:-1,
    aspect:-1,
    color:'green'
  },
  strand: {
    cnt:10,
    w:[],
    y:[],
    h:4,
    color:'white',
    wTotal:-1
  },
  ornament: {
    h:3,
    color1:'red',
    color2:'white',
    spacing:-1
  }
}
args.msg=document.getElementById('msg').textContent;
args.tree.aspect=args.tree.w/args.tree.h;
args.tree.hCenter=args.tree.w/2;

var c=document.getElementById('myCanvas');
var ctx=c.getContext('2d');

// Background
function drawBackground(ctx,args) {
  ctx.beginPath();
  ctx.fillStyle=args.bgColor;
  ctx.fillRect(0,0,args.tree.w,args.tree.h);
  ctx.closePath();
}

// Tree
function drawTree(ctx,args) {
  ctx.fillStyle=args.tree.color;
  ctx.beginPath();
  ctx.moveTo(args.tree.hCenter,0);
  ctx.lineTo(args.tree.w,args.tree.h);
  ctx.lineTo(0,args.tree.h);
  ctx.moveTo(args.tree.hCenter,0);
  ctx.fill();
  ctx.closePath();
}

// Horizontal strands
function drawStrands(ctx,args) {
  args.strand.wTotal=0;
  for (i=0; i<args.strand.cnt; i++) {
    var y=(i+1)*args.tree.h/(args.strand.cnt+1);
    var w=y*args.tree.aspect;			// width of strand[i]
    var wDiv2=w/2;

    // Set y[], w[] and wTotal for strand[i]
    args.strand.y.push(y);
    args.strand.w.push(w);
    args.strand.wTotal+=w;

    ctx.beginPath();
    ctx.strokeStyle=args.strand.color;
    ctx.lineWidth=args.strand.h;
    ctx.moveTo(args.tree.hCenter-(w/2),y);
    ctx.lineTo(args.tree.hCenter+(w/2),y);
    ctx.stroke();
    ctx.closePath();
  }
}

// Ornaments
function drawCircle(ctx,x,y,d,color) {
  ctx.beginPath();
  ctx.fillStyle=color;
  ctx.arc(x,y,d/2,0,Math.PI*2,true); 
  ctx.fill();  
  ctx.closePath();
}

// Mystery encoder must return a single array of boolean ornament placements
function encode(args) {
  var coding=[];
  for (var i=0; i<msg.length; i++) {
    var c=args.msg.charCodeAt(i)%256;
    var bits=[];
    for (var b=8; b>0; b--) {
      bits[b-1]=(c%2)==1;
      c=Math.floor(c/2);
    }
    coding.push.apply(coding,bits);
  }
  return coding;
}

function drawOrnaments(ctx,args,encode) {
  var coding=encode(args);					// boolean array of ornament placements
  var spacing=(args.strand.wTotal-(args.strand.cnt*args.ornament.h)) / coding.length;
  var c=0;
  for (var i=0; i<args.strand.cnt; i++) {
    var y=args.strand.y[i];
    var w=args.strand.w[i]-args.ornament.h;	// drawable width for this strand
    var x=args.tree.hCenter-(w/2);			// x pos of leftmost ornament
    var right=args.tree.hCenter+(w/2);		// x pos of rightmost ornament

    while (x<right) {
      drawCircle(ctx,x,y,args.ornament.h,
                 coding[c++]?args.ornament.color1:args.ornament.color2);
      x+=spacing;
    }
  }
}

drawBackground(ctx,args);
drawTree(ctx,args);
drawStrands(ctx,args);
drawOrnaments(ctx,args,encode);

</script>

</body>
</html>
